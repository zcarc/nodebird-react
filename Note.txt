
1. 노드 프로젝트 생성
	- ch1\front> npm init
	
	package name: react-nodebird-front
	version: enter
	~
	keyword: enter
	author: your name
	license: MIT
	yes
	
	
	npm init을 하면
	pakcage.json이 생성되는데 npm init을 사용하지 않고 직접 만들어도 상관 없다.
	
	
	
	ch1\front> npm i react react-dom next
	ch1\front> npm i -D nodemon webpack
	
	
	next: react 위에서 돌아가는 프레임워크
		  이걸 사용하는 이유는 코드 스플리팅과 서버사이드 렌더링에 필요하다.
			
			
			
	ch1\front> npm i -D eslint
	
	eslint: 사람마다 코딩스타일을 다르게해서 그 코딩 스타일 규칙을 정하는 라이브러리
	
	
	
	ch1\front> npm i -D eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks
	
	-D로 설치하면 package.json에서 devDependencies에 정의된다.
	devDependencies에 있는 패키지들은 개발할 때만 사용한다.
	
	dependencies에 넣어도 상관은 없는데 devDependencies에 넣는 것을 추천한다.



1-3. next 라우팅 시스템

        react는 page router를 많이 쓰는데
        next는 자체 router가 있어서 react router를 쓰지 않는다.
        그래서 더 간단하다.

        F:\node_bird\ch01\front> npm i -g next

        package.json
            "dev": "next" // 개발모드
            "build": "next build",
            "start": "next start" // 배포모드


        npm run dev를 하면 next가 호스팅을 알아서 해준다.
        이건 webpack-dev-server 와 비슷하다고 보면 된다.

        webpack-dev-server도 front react를 webpack으로 번들링 해주면서 서버로도 제공해준다.
        next도 그 역할을 모두 해준다.

        next는 js,jsx에서
        import React from 'react';를 하지 않아도 된다.


        pages 라는 폴더명을 만들고 거기에
        index.jsx를 만들면 기본 폴더가 pages 폴더라서 index.jsx가 출력된다.
        그래서 pages 폴더에 about.js를 만들고
        http://localhost:3000/about 이렇게 접속하면 about.jsx가 출력된다.
        pages 폴더가 주소체계를 표현해준다.



1-4.    1-4. ant design 적용하기

        node_bird\front> npm i antd

        실무에서는 ant design, bootstrap, semantic ui 가 많이 쓰인다.
        그대로 쓰지는 않고 커스터마이징해서 쓴다. 이유는 브랜드아이덴티티가 저해된다는 이유이다.
        그래서 외주 작업으로 어드민 페이지를 요구한다면 ant design으로 뚝딱 만들어버리면 된다.

        앤트 디자인으로 커버가 안되는 것들은 스타일드 컴포넌트를 사용한다.
        앤트 디자인을 사용할 때 커스터마이징을 스타일드 컴포넌트와 같이 할 수 있다.


        pages 폴더명은 고정이지만 components 폴더는 이름을 바꿔도 된다.
        next의 확장자는 js, jsx 둘 중 아무거나 사용해도 상관없다.
        그래서 "next convention"에 맞춰서 사용하면 된다.

        children이 props인데
        부모 컴포넌트에서 <AppLayout></AppLayout> 이런식으로 자식 컴포넌트를 불러오는데
        이 태그 안에 다른 태그들을 넣으면 그게 "children props"이다.


        앤트 디자인의 css를 불러오려면 next/head를 import하고 거기에 css 삽입하는 코드를 넣으면 된다.



1-5. 기본 페이지들 만들기

        index.jsx : main page
        profile.jsx : my profile page
        signup.jsx : sign up page

        <Link href="/profile"><a>프로필</a></Link>
        a 태그를 생략해도 동작하는데 문제는 없다.
        알아보니 a태그를 사용하지 않는것은 예전에 사용하던 방식이라 a태그를 사용해야한다.



1-7. 회원가입 state와 custom hook

        next가 webpack의 일부분들을 지원해준다.
        webpack이 최신문법에만 필요한게 아니라서 필요하기는 하다.

        useState는 함수, 반복문, 조건문에 넣지 않는게 좋은데
        커스텀 Hook에는 넣어도 된다.



2-1. _app.js로 레이아웃 분리하기

        원칙: props로 넘겨주는 함수는 useCallback 필수!
        useState가 변경될때마다 Input 태그가 넘겨주는 props 함수들이 다시 실행되서
        <Input name="user-password" type="password" value={password} required onChange={onChangePassword}></Input>
        name, type, value, onChange 모두 props 여기서 onChange는 함수인데 이 부분은 useState시 새로 생성되므로 useCallback을 사용해야한다.


        useCallback()의 두번째 인자 배열안에는 함수 내부에서 쓰는 state를 deps 배열로 넣는다.


        pages/_app.jsx 는 next에서 지정해놓은 레이아웃을 위한 파일명이다.
        _app.jsx의 props인 Component는 index.jsx, profile.jsx, signup.jsx의 "Component"이다.


        // 특정 부분만 골라서 최적화 하는 방법
        // 지나친 최적화도 별로 좋지 않다.
        const TextInput = memo(({ value, onChange }) => {
            return(
                <Input value={value} required onChange={onChange}></Input>
            );
        });


        기존 signup.jsx에는 render() 안에 <AppLayout /> 컴포넌트를 사용했었는데
        이렇게 되면 render()가 될 때마다 Layout를 렌더링 하므로  성능상에 문제가 있다.
        그래서 해당 컴포넌트들을 분리시켜야하는데 그러기 위해서 pages/_app.jsx를 생성한다. 이 파일명은 약속이다.



2-2. prop-types

        ch01\front> npm i prop-types

        // PropTypes.elementType: props에서 받은 컴포넌트
        NodeBird.propTypes = {
          Component: PropTypes.elementType,
        };


        _document.jsx : html, head, body
        _app.jsx : root (리액트 컴포넌트를 렌더링할 root)
        _error.jsx : 에러 발생 시 출력
        pages/ : 실제 컴포넌트

        _로 시작하는 위 3개 파일들은 기본적으로 next에 내장되어 있는데
        직접 커스터마이징하면 기존 파일을 덮어 씌울 수 있다.



2-3. antd 그리드 시스템

        backend, front 개발자가 서로 협업을 할 때
        API구조를 알아야 통신하는 방법을 알기 때문에 문서화를 잘해야 커뮤니케이션이 잘된다.


2-4. 커스텀 훅 재사용하기

        반복문 map()을 사용할 때 내부의 컴포넌트도 쪼개는게 좋다.
        
        const를 export할 때는 import 할때 비구조화 할당으로 가져와야한다.



2-6. 프로필 화면 만들기        

        최적화를 할 때 조건문, 반복문에 대한 컴포넌트를 분리해야한다.
        컴포넌트를 분리하는 쉬운 기준은 조건문, 반복문이다.        



2-7. 컴포넌트 분리하기

        form 태그는 안에 state가 있기 때문에 다른 부분도 렌더링이 되서
        따로 컴포넌트를 만들어 주는게 좋다.



3-1. Redux 주요 개념 소개

        Redux는 state의 역할을 하기 때문에 React의 State를 쓰지 않아도 된다.
        근데 보통은 둘 다 같이 쓰인다.        
        간단한 것은 React state
        복잡한 것은 Redux의 state를 주로 쓴다.

        Redux를 쓰는 이유: state 통제의 용이, 안정성

        store : state와 action, reducer가 다 합쳐진 개념

        Action: state를 바꾸는 행동
        Dispatch: Action을 실행
        Reducer: Action의 결과로 state를 어떻게 바꿀지 정의
        
        
        Redux는 Vue와 같은 다른 라이브러리에도 사용할 수 있고
        노드 같은 서버쪽 앱에도 사용할 수 있다.
        리덕스는 리액트와는 별개이고
        리액트에서 리덕스를 제일 많이 사용하기는 한다.



3-2. 첫 리듀서 만들기

        ch03/front> npm i redux react-redux

        redux: redux 기본 패키지
        react-redux: react와 redux를 연결해주는 패키지 (redux는 react와 아무런 관련이 없어서 연결해줘야한다.)


        ch03/front> npm i react react-dom next prop-types antd
        ch03/front> npm i -D eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks nodemon webpack


        리덕스의 단점은 코드량이 많아진다.
        하지만 예상치 못한 동작이 일어날 일은 없다.

        state 구조 잡는 건 경험이 많이 쌓여야 잘 잡을 수 있다.


        리덕스는 하나로 모아뒀다고 하지만 실제로 하나로 모으면
        너무 파일 하나가 너무 커지기 때문에 하나씩 쪼개는 것을 허용해준다.
        단, root store는 동일해야한다.



3-3. 불변성과 리듀서 여러 개 합치기

        combineReducers(): 흩어져 있는 reducer들을 합쳐주는 메서드
        


3-4. redux와 react 연결하기        

        Provider가 redux state를 제공해준다.

        store: state, action, reducer가 합쳐진 것

        Provider로 감싸주게 되면 해주면
        자식 컴포넌트들은 중앙 통제실의 state들을 전부 받는다.
        Provider가 제일 최상위 부모이다.
        <Provider store={store}> 


        react-redux와
        next-redux는 서로 다르다.
         
        next에서는
        ch03/front> npm i next-redux-wrapper 를 설치해줘야한다.


        // 이 부분의 store는 next-reducer-wrapper가 전달해준다.
        const NodeBird = ({ Component, store })

        export default withRedux((initialState, options) => {
        })(NodeBird);

        export할 때 withRedux()를 사용해서 store를 어떻게 넘겨줘야할지 작성해야한다.
        모든 프로젝트에서 위와 같이 사용하므로 이해가 안된다면 외우는게 좋다.

        action이 dispatch될 때 state를 어떻게 바꿔야할지 정의하는게
        reduce이고 이것들을 전부합쳐서 store로 만들고
        widthRedux()에서 store를 반환하면

        // 이 부분이 store를 받을 수 있다.
        const NodeBird = ({ Component, store })

        그리고 widthRedux() 내부에서 store를 커스터마이징하는 경우도 있다.


        redux의 state들의 switch문에서 default가 없으면 에러가 발생하니 추가해줘야한다.

        
        switch문의 default는 실행될리가 없다고 보면 된다.
        이유는 정해진 action만 실행되기 때문에
        오타나 아무 행동도 안하는 경우가 아니면 default가 실행되지 않는다
        아무 행동도 안하는 경우는 단순히 로그를 띄울 때(로깅)가 있을 수 있다.
        
        reducer는 action이 실행되어야 실행되므로 실행되었을 때 default에 걸린다.
        그래서 action이 실행되면 무조건 새로운 state를 반환해줘야한다.

        action 하나당 새로운 state 하나씩 매칭해줘야한다.
        새로운 객체가 만들어지는게 원칙적으로 맞다.

        
        default: {
            return {
                ...state,
            };
        }

        default: {
            return state;
        }

        아무거나 써도 상관은 없지만 redux 원칙의 불변성을 따르는게 좋아서 첫번째 방법을 사용한다.

        

3-5. redux devtools 사용하기

        redux devtools(확장프로그램)을 사용하면
        어떤 action이 실행되서 state가 바뀌었는지 추적할 수 있다.
        그리고 역추적 time-machine도 할 수 있다.

        withRedux()에 middlewares를 추가해야하는데
        '미들웨어'라는것은 store에서 state,action,reducer 중간에 껴서 
        그 과정을 변조하거나 기능을 추가하는게 '미들웨어'이다.

        'redux'가 하는것은 단순히 state를 action과 reducer를 따라서 바꾸는 것이다.
        이것은 가장 기본적인 기능이고 redux에 없는 기능들을 추가하고 싶을 때 바로 미들웨어를 사용한다.

        크롬에서 redux 확장프로그램을 사용하는것도 원래 없는 기능인데 이를 하기 위해서
        withRedux()에 미들웨어를 사용해야한다.

        미들웨어는 action과 store 사이에서 동작한다.


        // 이 코드는 redux devtools 사이트에서 가져왔다.
        // redux devtools 확장프로그램을 깔게 되면 window 객체에 __REDUX_DEVTOOLS_EXTENSION__ 라는 함수가 생긴다.
        window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,

        // 기존 미들웨어들에 __REDUX_DEVTOOLS_EXTENSION__를 추가해서 '합성'한다는 의미이다.
        const enhancer = compose(
                applyMiddleware(...middlewares),
                window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,
        );

        // 아래 코드는 그냥 외우면 된다. 이유는 나중에 리덕스 사가를 사용하면
        window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,

        
        compose() : middleware 끼리 합성을 하게 만드는 함수
        applyMiddleware(...middlewares): middlewares = [미들웨어1, 미들웨어2 ...] 에 정의된 미들웨어들을 적용

        compose()로 "applyMiddleware(...middlewares)"와 "__REDUX_DEVTOOLS_EXTENSION__"를 합쳐준다.
        여기서 큰 틀은 그대로 유지하고 바뀌는 부분은 middlewares에 들어가는 미들웨어들만 거의 바뀐다.


        window is not defined 가 뜬다면 서버사이드 렌더링 시 서버에서 window를 이해할 수 없기 때문이다.


        // 서버사이드 렌더링인 경우 window 객체가 없다.
        // 이 코드 대신에 쓸 수 있는 코드가 있다.
        typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,

        // 아래코드로 대체가 가능하다.
        // options.isServer는 next에서 제공하는 속성이다.
        !options.isServer && window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,


        
3-6. react-redux 훅 사용하기

        react-redux가 원래 hook을 지원안했다가 최근에 지원하기 시작했다.
        7.1 버전 이상이면 @next로 그 다음 버전을 설치할 필요가 없다.
        ch03/front> npm i react-redux@next
        @next는 현재 버전의 다음 버전이다 패키지 next와 연관이 없다.

        ...state : 점 3개가 있는 것을 스프레드 문법이라고 한다.


        react-redux에 hooks가 들어와서
        connect는 class component에만 쓰이고
        함수 component는 전부 hooks로 진행한다.
        hooks가 훨씬 더 편하다.


        useSelect() : 리액트 리덕스 Hooks

        // 전체 state에서 user의 state를 선택한다.
        const user = useSelector(state => state.user);


        아래 두 메서드 리액트 Hooks, 리덕스 Hooks 같은 의미라고 생각하면 된다.
        useState() == useSelector()
        setState() == useDispatch()



3-7. react-redux connect

        useSelector(), useDispatch()는 원래 하이오더 컴포넌트였다.

        react hooks가 없었을 때는 redux connect를 사용했었다.

        
        action은 state를 어떻게 바꿀지 정의하고
        dispatch는 reducer에게 action을 보낸다.
        그럼 reducer는 dispatch에게 전달받은 action을 실행해서 리덕스 state에 반영한다.

        
        useSelect()로 state를 가져오는 컴포넌트는
        가져온 state가 변경되면 해당 컴포넌트도 다시 re-rendering 된다.


        action에 넣을 데이터가 동적인 경우에는 action을 함수로 만들어야한다.

        Form 같은 태그들은 리덕스 안쓰고 리액트 state 쓴다. 
        리덕스는 서버와 통신할 데이터 or 여러 컴포넌트가 같이 쓰는 
        데이터들은 redux state를 쓰는게 좀 더 낫다.



4-1. 리덕스 사가의 필요성과 맛보기

        ch03/front> npm i redux-saga


        <제네레이터>

        1. 제네레이터의 장점은 무엇인가?
           - 함수 실행을 중간에 멈출 수 있고 원할 때 재개할 수 있어 편하다.

        2. 주로 어디에 쓰이는가?
           - 주로 무한의 개념을 표현할 때와 비동기 처리를 할 때 많이 사용한다.

        3. 어렵게 느껴진다면?
           - 사가도 패턴이 있어 패턴대로 하면 된다.


        takeLatest(): LOG_IN 액션이 dispatch() 되기를 기다려서
                      dispatch 될 때 login 제네레이터를 호출한다.


        리덕스는 기본적으로 동기식으로 동작하므로
        사가를 사용하면 비동기로 만들어준다.         

        
        call(): 함수 동기적 호출
        fork(): 함수 비동기적 호출
        put(): 액션 dispatch 동일



4-2. 사가 미들웨어 리덕스에 연결하기

        실제 서비스에서는 리덕스 확장프로그램을 허용하면 보안에 취약해지기 때문에 "_app.jsx" 에서 아래 부분은 삭제하고 배포한다.
        window.__REDUX_DEVTOOLS_EXTENSION__


        사가 미들웨어는 currying 기법을 사용하는데 인자 하나를 받아서 다른 함수를 리턴한다.
        제네레이터는 함수 실행을 중간에 멈출 수 있고 기존 컴포넌트에 props 같은 것을 추가할 때 쓴다.



4-3. ES2015 제너레이터

        
