
1. 노드 프로젝트 생성
	- ch1\front> npm init
	
	package name: react-nodebird-front
	version: enter
	~
	keyword: enter
	author: your name
	license: MIT
	yes
	
	
	npm init을 하면
	pakcage.json이 생성되는데 npm init을 사용하지 않고 직접 만들어도 상관 없다.
	
	
	
	ch1\front> npm i react react-dom next
	ch1\front> npm i -D nodemon webpack
	
	
	next: react 위에서 돌아가는 프레임워크
		  이걸 사용하는 이유는 코드 스플리팅과 서버사이드 렌더링에 필요하다.
			
			
			
	ch1\front> npm i -D eslint
	
	eslint: 사람마다 코딩스타일을 다르게해서 그 코딩 스타일 규칙을 정하는 라이브러리
	
	
	
	ch1\front> npm i -D eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks
	
	-D로 설치하면 package.json에서 devDependencies에 정의된다.
	devDependencies에 있는 패키지들은 개발할 때만 사용한다.
	
	dependencies에 넣어도 상관은 없는데 devDependencies에 넣는 것을 추천한다.



1-3. next 라우팅 시스템

        react는 page router를 많이 쓰는데
        next는 자체 router가 있어서 react router를 쓰지 않는다.
        그래서 더 간단하다.

        F:\node_bird\ch01\front> npm i -g next

        package.json
            "dev": "next" // 개발모드
            "build": "next build",
            "start": "next start" // 배포모드


        npm run dev를 하면 next가 호스팅을 알아서 해준다.
        이건 webpack-dev-server 와 비슷하다고 보면 된다.

        webpack-dev-server도 front react를 webpack으로 번들링 해주면서 서버로도 제공해준다.
        next도 그 역할을 모두 해준다.

        next는 js,jsx에서
        import React from 'react';를 하지 않아도 된다.


        pages 라는 폴더명을 만들고 거기에
        index.jsx를 만들면 기본 폴더가 pages 폴더라서 index.jsx가 출력된다.
        그래서 pages 폴더에 about.js를 만들고
        http://localhost:3000/about 이렇게 접속하면 about.jsx가 출력된다.
        pages 폴더가 주소체계를 표현해준다.



1-4.    1-4. ant design 적용하기

        node_bird\front> npm i antd

        실무에서는 ant design, bootstrap, semantic ui 가 많이 쓰인다.
        그대로 쓰지는 않고 커스터마이징해서 쓴다. 이유는 브랜드아이덴티티가 저해된다는 이유이다.
        그래서 외주 작업으로 어드민 페이지를 요구한다면 ant design으로 뚝딱 만들어버리면 된다.

        앤트 디자인으로 커버가 안되는 것들은 스타일드 컴포넌트를 사용한다.
        앤트 디자인을 사용할 때 커스터마이징을 스타일드 컴포넌트와 같이 할 수 있다.


        pages 폴더명은 고정이지만 components 폴더는 이름을 바꿔도 된다.
        next의 확장자는 js, jsx 둘 중 아무거나 사용해도 상관없다.
        그래서 "next convention"에 맞춰서 사용하면 된다.

        children이 props인데
        부모 컴포넌트에서 <AppLayout></AppLayout> 이런식으로 자식 컴포넌트를 불러오는데
        이 태그 안에 다른 태그들을 넣으면 그게 "children props"이다.


        앤트 디자인의 css를 불러오려면 next/head를 import하고 거기에 css 삽입하는 코드를 넣으면 된다.



1-5. 기본 페이지들 만들기

        index.jsx : main page
        profile.jsx : my profile page
        signup.jsx : sign up page

        <Link href="/profile"><a>프로필</a></Link>
        a 태그를 생략해도 동작하는데 문제는 없다.
        알아보니 a태그를 사용하지 않는것은 예전에 사용하던 방식이라 a태그를 사용해야한다.



1-7. 회원가입 state와 custom hook

        next가 webpack의 일부분들을 지원해준다.
        webpack이 최신문법에만 필요한게 아니라서 필요하기는 하다.

        useState는 함수, 반복문, 조건문에 넣지 않는게 좋은데
        커스텀 Hook에는 넣어도 된다.



2-1. _app.js로 레이아웃 분리하기

        원칙: props로 넘겨주는 함수는 useCallback 필수!
        useState가 변경될때마다 Input 태그가 넘겨주는 props 함수들이 다시 실행되서
        <Input name="user-password" type="password" value={password} required onChange={onChangePassword}></Input>
        name, type, value, onChange 모두 props 여기서 onChange는 함수인데 이 부분은 useState시 새로 생성되므로 useCallback을 사용해야한다.


        useCallback()의 두번째 인자 배열안에는 함수 내부에서 쓰는 state를 deps 배열로 넣는다.


        pages/_app.jsx 는 next에서 지정해놓은 레이아웃을 위한 파일명이다.
        _app.jsx의 props인 Component는 index.jsx, profile.jsx, signup.jsx의 "Component"이다.


        // 특정 부분만 골라서 최적화 하는 방법
        // 지나친 최적화도 별로 좋지 않다.
        const TextInput = memo(({ value, onChange }) => {
            return(
                <Input value={value} required onChange={onChange}></Input>
            );
        });


        기존 signup.jsx에는 render() 안에 <AppLayout /> 컴포넌트를 사용했었는데
        이렇게 되면 render()가 될 때마다 Layout를 렌더링 하므로  성능상에 문제가 있다.
        그래서 해당 컴포넌트들을 분리시켜야하는데 그러기 위해서 pages/_app.jsx를 생성한다. 이 파일명은 약속이다.



2-2. prop-types

        ch01\front> npm i prop-types

        // PropTypes.elementType: props에서 받은 컴포넌트
        NodeBird.propTypes = {
          Component: PropTypes.elementType,
        };


        _document.jsx : html, head, body
        _app.jsx : root (리액트 컴포넌트를 렌더링할 root)
        _error.jsx : 에러 발생 시 출력
        pages/ : 실제 컴포넌트

        _로 시작하는 위 3개 파일들은 기본적으로 next에 내장되어 있는데
        직접 커스터마이징하면 기존 파일을 덮어 씌울 수 있다.



2-3. antd 그리드 시스템

        backend, front 개발자가 서로 협업을 할 때
        API구조를 알아야 통신하는 방법을 알기 때문에 문서화를 잘해야 커뮤니케이션이 잘된다.


2-4. 커스텀 훅 재사용하기

        반복문 map()을 사용할 때 내부의 컴포넌트도 쪼개는게 좋다.
        
        const를 export할 때는 import 할때 비구조화 할당으로 가져와야한다.



2-6. 프로필 화면 만들기        

        최적화를 할 때 조건문, 반복문에 대한 컴포넌트를 분리해야한다.
        컴포넌트를 분리하는 쉬운 기준은 조건문, 반복문이다.        



2-7. 컴포넌트 분리하기

        form 태그는 안에 state가 있기 때문에 다른 부분도 렌더링이 되서
        따로 컴포넌트를 만들어 주는게 좋다.



3-1. Redux 주요 개념 소개

        Redux는 state의 역할을 하기 때문에 React의 State를 쓰지 않아도 된다.
        근데 보통은 둘 다 같이 쓰인다.        
        간단한 것은 React state
        복잡한 것은 Redux의 state를 주로 쓴다.

        Redux를 쓰는 이유: state 통제의 용이, 안정성

        store : state와 action, reducer가 다 합쳐진 개념

        Action: state를 바꾸는 행동
        Dispatch: Action을 실행
        Reducer: Action의 결과로 state를 어떻게 바꿀지 정의
        
        
        Redux는 Vue와 같은 다른 라이브러리에도 사용할 수 있고
        노드 같은 서버쪽 앱에도 사용할 수 있다.
        리덕스는 리액트와는 별개이고
        리액트에서 리덕스를 제일 많이 사용하기는 한다.